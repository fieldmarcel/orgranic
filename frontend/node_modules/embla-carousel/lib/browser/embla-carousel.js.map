{"version":3,"file":"embla-carousel.js","sources":["../../src/vanilla/components/alignment.ts","../../src/vanilla/components/counter.ts","../../src/vanilla/components/vector1d.ts","../../src/vanilla/components/direction.ts","../../src/vanilla/components/eventStore.ts","../../src/vanilla/components/dragHandler.ts","../../src/vanilla/components/dragTracker.ts","../../src/vanilla/components/limit.ts","../../src/vanilla/components/utils.ts","../../src/vanilla/components/scrollBody.ts","../../src/vanilla/components/scrollBounds.ts","../../src/vanilla/components/scrollContain.ts","../../src/vanilla/components/scrollLooper.ts","../../src/vanilla/components/scrollTarget.ts","../../src/vanilla/components/slideLooper.ts","../../src/vanilla/components/slidesInView.ts","../../src/vanilla/components/translate.ts","../../src/vanilla/components/engine.ts","../../src/vanilla/components/scrollProgress.ts","../../src/vanilla/components/axis.ts","../../src/vanilla/components/pxToPercent.ts","../../src/vanilla/components/scrollSnap.ts","../../src/vanilla/components/scrollLimit.ts","../../src/vanilla/components/animation.ts","../../src/vanilla/components/scrollTo.ts","../../src/vanilla/components/options.ts","../../src/vanilla/index.ts","../../src/vanilla/components/eventEmitter.ts"],"sourcesContent":["export type AlignmentOption = 'start' | 'center' | 'end' | number\n\ntype Params = {\n  viewSize: number\n  align: AlignmentOption\n}\n\nexport type Alignment = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(params: Params): Alignment {\n  const { viewSize, align } = params\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return (viewSize - n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (typeof align === 'number') return percent()\n    return predefined[align](n)\n  }\n\n  const self: Alignment = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\n\ntype Params = {\n  start: number\n  limit: Limit\n  loop: boolean\n}\n\nexport type Counter = {\n  min: number\n  max: number\n  get: () => number\n  set: (n: number) => Counter\n  add: (n: number) => Counter\n  clone: () => Counter\n}\n\nexport function Counter(params: Params): Counter {\n  const { start, limit, loop } = params\n  const { min, max } = limit\n  const type = loop ? 'loop' : 'constrain'\n  let counter = withinLimit(start)\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): Counter {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function withinLimit(n: number): number {\n    return limit[type](n)\n  }\n\n  function add(n: number): Counter {\n    if (n !== 0) {\n      const sign = n / Math.abs(n)\n      set(get() + sign)\n      return add(n + sign * -1)\n    }\n    return self\n  }\n\n  function clone(): Counter {\n    return Counter({ start: get(), limit, loop })\n  }\n\n  const self: Counter = {\n    add,\n    clone,\n    get,\n    max,\n    min,\n    set,\n  }\n  return self\n}\n","export type Vector1D = {\n  get: () => number\n  set: (v: Vector1D | number) => Vector1D\n  add: (v: Vector1D | number) => Vector1D\n  subtract: (v: Vector1D | number) => Vector1D\n  multiply: (n: number) => Vector1D\n  divide: (n: number) => Vector1D\n  normalize: () => Vector1D\n}\n\nexport function Vector1D(value: number): Vector1D {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1D | number): Vector1D {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1D | number): Vector1D {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1D | number): Vector1D {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1D {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1D {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1D {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1D | number): number {\n    return typeof n === 'number' ? n : n.get()\n  }\n\n  const self: Vector1D = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { Vector1D } from './vector1d'\n\nexport type Direction = {\n  get: () => number\n  set: (v: Vector1D) => Direction\n}\n\nexport function Direction(value: number): Direction {\n  const direction = Vector1D(normalize(value))\n  const { get } = direction\n\n  function normalize(n: number): number {\n    return n === 0 ? 0 : n / Math.abs(n)\n  }\n\n  function set(v: Vector1D): Direction {\n    const d = normalize(v.get())\n    if (d !== 0) direction.set(d)\n    return self\n  }\n\n  const self: Direction = {\n    get,\n    set,\n  }\n  return self\n}\n","type EventRemover = () => void\ntype EventHandler = EventListener | EventListenerObject | null\ntype EventOptions = boolean | AddEventListenerOptions | undefined\n\nexport type EventStore = {\n  add: (\n    node: EventTarget,\n    type: string,\n    handler: EventHandler,\n    options?: EventOptions,\n  ) => EventStore\n  removeAll: () => EventStore\n}\n\nexport function EventStore(): EventStore {\n  const listeners: EventRemover[] = []\n\n  function add(\n    node: EventTarget,\n    type: string,\n    handler: EventHandler,\n    options: EventOptions = false,\n  ): EventStore {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => {\n      return node.removeEventListener(type, handler, options)\n    })\n    return self\n  }\n\n  function removeAll(): EventStore {\n    listeners.filter(remove => remove())\n    listeners.length = 0\n    return self\n  }\n\n  const self: EventStore = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Counter } from './counter'\nimport { Direction } from './direction'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitter } from './eventEmitter'\nimport { Axis } from './axis'\nimport { EventStore } from './eventStore'\nimport { Limit } from './limit'\nimport { ScrollBody } from './scrollBody'\nimport { ScrollTarget } from './scrollTarget'\nimport { ScrollTo } from './scrollTo'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  element: HTMLElement\n  target: Vector1D\n  dragFree: boolean\n  dragTracker: DragTracker\n  location: Vector1D\n  animation: Animation\n  scrollTo: ScrollTo\n  scrollBody: ScrollBody\n  scrollTarget: ScrollTarget\n  index: Counter\n  limit: Limit\n  loop: boolean\n  events: EventEmitter\n}\n\nexport type DragHandler = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeActivationEvents: EventStore['removeAll']\n  removeInteractionEvents: EventStore['removeAll']\n}\n\nexport function DragHandler(params: Params): DragHandler {\n  const { target, scrollBody, dragFree, animation, axis } = params\n  const { element, dragTracker, location, events, limit } = params\n  const { scroll: scrollAxis, cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const startScroll = Vector1D(0)\n  const startCross = Vector1D(0)\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const removeActivationEvents = activationEvents.removeAll\n  const removeInteractionEvents = interactionEvents.removeAll\n  const snapForceBoost = { mouse: 2.5, touch: 3.5 }\n  const freeForceBoost = { mouse: 4, touch: 7 }\n  const snapSpeed = { mouse: 12, touch: 14 }\n  const freeSpeed = { mouse: 6, touch: 5 }\n  const dragThreshold = 4\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = element\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? element : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function movementSpeed(): number {\n    const speed = dragFree ? freeSpeed : snapSpeed\n    const type = isMouse ? 'mouse' : 'touch'\n    return speed[type]\n  }\n\n  function dragForceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function seekTargetBy(force: number): void {\n    const { scrollTo, scrollTarget, index } = params\n    const reachedLimit = limit.reachedAny(target.get() + force)\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const seekNext = !targetChanged && Math.abs(force) > dragThreshold\n\n    if (!dragFree && !reachedLimit && seekNext) {\n      const indexDiff = Direction(force).get() * -1\n      const next = index.clone().add(indexDiff)\n      scrollTo.index(next.get(), 0)\n    } else {\n      scrollTo.distance(force, !dragFree)\n    }\n  }\n\n  function down(evt: Event): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = delta(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useDefaultMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis))\n    startCross.set(dragTracker.readPoint(evt, crossAxis))\n    events.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: Event): void {\n    if (!preventScroll && !isMouse) {\n      const moveScroll = dragTracker.readPoint(evt, scrollAxis).get()\n      const moveCross = dragTracker.readPoint(evt, crossAxis).get()\n      const diffScroll = delta(moveScroll, startScroll.get())\n      const diffCross = delta(moveCross, startCross.get())\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up()\n    }\n    const diff = dragTracker.pointerMove(evt)\n    const reachedLimit = limit.reachedAny(location.get())\n    const resist = !params.loop && reachedLimit ? 2 : 1\n\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(diff / resist)\n    evt.preventDefault()\n  }\n\n  function up(): void {\n    const force = dragTracker.pointerUp() * dragForceBoost()\n    const isMoving = delta(target.get(), dragStartPoint.get()) >= 0.5\n\n    if (isMoving && !isMouse) preventClick = true\n    isMouse = false\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(movementSpeed())\n    seekTargetBy(force)\n    events.emit('pointerUp')\n  }\n\n  function delta(pointB: number, pointA: number): number {\n    return Math.abs(pointB - pointA)\n  }\n\n  function click(evt: Event): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandler = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeActivationEvents,\n    removeInteractionEvents,\n  }\n  return self\n}\n","import { Axis, AxisOption } from './axis'\nimport { PxToPercent } from './pxToPercent'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  pxToPercent: PxToPercent\n}\n\nexport type DragTracker = {\n  pointerDown: (evt: Event) => number\n  pointerMove: (evt: Event) => number\n  pointerUp: () => number\n  readPoint: (evt: any, axis: AxisOption) => Vector1D\n}\n\nexport function DragTracker(params: Params): DragTracker {\n  const { axis, pxToPercent } = params\n  const { scroll: scrollAxis } = axis\n  const coords = { x: 'clientX', y: 'clientY' }\n  const startDrag = Vector1D(0)\n  const diffDrag = Vector1D(0)\n  const lastDrag = Vector1D(0)\n  const pointValue = Vector1D(0)\n  const trackInterval = 10\n  let trackPoints: number[] = []\n  let trackTime = new Date().getTime()\n  let isMouse = false\n\n  function readPoint(evt: any, type: AxisOption): Vector1D {\n    isMouse = !evt.touches\n    const c = coords[type]\n    const value = isMouse ? evt[c] : evt.touches[0][c]\n    return pointValue.set(value)\n  }\n\n  function pointerDown(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    startDrag.set(point)\n    lastDrag.set(point)\n    return pxToPercent.measure(startDrag.get())\n  }\n\n  function pointerMove(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    const time2 = new Date().getTime()\n    const time1 = trackTime\n\n    if (time2 - time1 >= trackInterval) {\n      trackPoints.push(point.get())\n      trackTime = time2\n    }\n\n    diffDrag.set(point).subtract(lastDrag)\n    lastDrag.set(point)\n    return pxToPercent.measure(diffDrag.get())\n  }\n\n  function pointerUp(): number {\n    const currentPoint = lastDrag.get()\n    const trackLength = isMouse ? 5 : 4\n    const point = trackPoints\n      .slice(-trackLength)\n      .map(trackPoint => currentPoint - trackPoint)\n      .sort((p1, p2) => {\n        return Math.abs(p1) < Math.abs(p2) ? 1 : -1\n      })[0]\n\n    lastDrag.set(point || 0)\n    trackPoints = []\n    return pxToPercent.measure(lastDrag.get())\n  }\n\n  const self: DragTracker = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","type Limits = 'min' | 'max' | ''\n\ntype Params = {\n  min: number\n  max: number\n}\n\nexport type Limit = {\n  min: number\n  max: number\n  length: number\n  loop: (n: number) => number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(params: Params): Limit {\n  const { min, max } = params\n  const loopLimits = { min: max, max: min }\n  const constrainLimits = { min, max }\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function reachedWhich(n: number): Limits {\n    if (reachedMin(n)) return 'min'\n    if (reachedMax(n)) return 'max'\n    return ''\n  }\n\n  function removeOffset(n: number): number {\n    if (min === max) return n\n    while (reachedMin(n)) n += length\n    while (reachedMax(n)) n -= length\n    return n\n  }\n\n  function loop(n: number): number {\n    const which = reachedWhich(n)\n    return which ? loopLimits[which] : n\n  }\n\n  function constrain(n: number): number {\n    const which = reachedWhich(n)\n    return which ? constrainLimits[which] : n\n  }\n\n  const self: Limit = {\n    constrain,\n    length,\n    loop,\n    max,\n    min,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return (\n    oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n  )\n}\n\nexport function arrayFromCollection(\n  nodeList: HTMLCollection,\n): HTMLElement[] {\n  return Array.prototype.slice.call(nodeList)\n}\n\nexport function debounce(\n  callback: () => void,\n  time: number,\n): () => void {\n  const timeout = { id: 0 }\n  return (): void => {\n    window.clearTimeout(timeout.id)\n    timeout.id = window.setTimeout(callback, time) || 0\n  }\n}\n\nexport function roundToDecimals(\n  decimalPoints: number,\n): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number) => Math.round(n * pow) / pow\n}\n\nexport function groupArray<GenericType>(\n  array: GenericType[],\n  size: number,\n): GenericType[][] {\n  const groups = []\n  for (let i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size))\n  }\n  return groups\n}\n\nexport function arrayKeys<GenericType>(array: GenericType): number[] {\n  return Object.keys(array).map(Number)\n}\n\nexport function removeClass(\n  node: HTMLElement,\n  className: string,\n): void {\n  const cl = node.classList\n  if (cl.contains(className)) cl.remove(className)\n}\n\nexport function addClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (!cl.contains(className)) cl.add(className)\n}\n","import { Direction } from './direction'\nimport { map, roundToDecimals } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  location: Vector1D\n  speed: number\n  mass: number\n}\n\nexport type ScrollBody = {\n  location: Vector1D\n  direction: Direction\n  update: () => void\n  seek: (v: Vector1D) => ScrollBody\n  settle: (v: Vector1D) => boolean\n  useSpeed: (n: number) => ScrollBody\n  useDefaultSpeed: () => ScrollBody\n  useMass: (n: number) => ScrollBody\n  useDefaultMass: () => ScrollBody\n}\n\nexport function ScrollBody(params: Params): ScrollBody {\n  const { location, speed, mass } = params\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n  const direction = Direction(0)\n  const state = { speed, mass }\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(v: Vector1D): void {\n    v.divide(state.mass)\n    acceleration.add(v)\n  }\n\n  function seek(v: Vector1D): ScrollBody {\n    attraction.set(v).subtract(location)\n    const magnitude = attraction.get()\n    const m = map(magnitude, 0, 100, 0, state.speed)\n    direction.set(attraction)\n    attraction\n      .normalize()\n      .multiply(m)\n      .subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(v: Vector1D): boolean {\n    const diff = v.get() - location.get()\n    const diffRounded = roundToTwoDecimals(diff)\n    const hasSettled = !diffRounded\n    if (hasSettled) location.set(v)\n    return hasSettled\n  }\n\n  function useSpeed(n: number): ScrollBody {\n    state.speed = n\n    return self\n  }\n\n  function useDefaultSpeed(): ScrollBody {\n    useSpeed(speed)\n    return self\n  }\n\n  function useMass(n: number): ScrollBody {\n    state.mass = n\n    return self\n  }\n\n  function useDefaultMass(): ScrollBody {\n    useMass(mass)\n    return self\n  }\n\n  const self: ScrollBody = {\n    direction,\n    location,\n    seek,\n    settle,\n    update,\n    useDefaultMass,\n    useDefaultSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Limit } from './limit'\nimport { ScrollBody } from './scrollBody'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  limit: Limit\n  location: Vector1D\n  scrollBody: ScrollBody\n  animation: Animation\n}\n\nexport type ScrollBounds = {\n  constrain: (v: Vector1D) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(params: Params): ScrollBounds {\n  const { limit, location, scrollBody, animation } = params\n  const { min, max, reachedMin, reachedMax } = limit\n  const tolerance = 50\n  let disabled = false\n  let timeout = 0\n\n  function shouldConstrain(v: Vector1D): boolean {\n    if (disabled || timeout) return false\n    if (reachedMin(location.get())) return v.get() !== min\n    if (reachedMax(location.get())) return v.get() !== max\n    return false\n  }\n\n  function constrain(v: Vector1D): void {\n    if (!shouldConstrain(v)) return\n\n    timeout = window.setTimeout(() => {\n      const constraint = limit.constrain(v.get())\n      v.set(constraint)\n      scrollBody.useSpeed(10).useMass(3)\n      animation.start()\n      timeout = 0\n    }, tolerance)\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBounds = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Limit } from './limit'\n\nexport type ScrollContainOption = '' | 'trimSnaps' | 'keepSnaps'\n\ntype Params = {\n  contentSize: number\n  viewSize: number\n  alignment: Alignment\n}\n\nexport type ScrollContain = {\n  measure: (scrollSnaps: number[], trim: boolean) => number[]\n}\n\nexport function ScrollContain(params: Params): ScrollContain {\n  const { alignment, contentSize, viewSize } = params\n  const scrollBounds = Limit({ min: -contentSize + viewSize, max: 0 })\n  const alignedWithinView = [alignment.measure(contentSize)]\n  const contentExceedsView = contentSize > viewSize\n\n  function findDuplicates(scrollSnaps: number[]): Limit {\n    const startSnap = scrollSnaps[0]\n    const endSnap = scrollSnaps[scrollSnaps.length - 1]\n    const min = scrollSnaps.lastIndexOf(startSnap) + 1\n    const max = scrollSnaps.indexOf(endSnap)\n    return Limit({ min, max })\n  }\n\n  function measure(scrollSnaps: number[], trim: boolean): number[] {\n    const containedSnaps = scrollSnaps.map(scrollBounds.constrain)\n    const { min, max } = findDuplicates(containedSnaps)\n\n    if (!contentExceedsView) return alignedWithinView\n    if (!trim) return containedSnaps\n    return containedSnaps.slice(min - 1, max + 1)\n  }\n\n  const self: ScrollContain = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\nimport { PxToPercent } from './pxToPercent'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  contentSize: number\n  limit: Limit\n  location: Vector1D\n  pxToPercent: PxToPercent\n}\n\nexport type ScrollLooper = {\n  loop: (vectors: Vector1D[], direction: number) => void\n}\n\nexport function ScrollLooper(params: Params): ScrollLooper {\n  const { contentSize, location, limit, pxToPercent } = params\n  const min = limit.min + pxToPercent.measure(0.1)\n  const max = limit.max + pxToPercent.measure(0.1)\n  const { reachedMin, reachedMax } = Limit({ min, max })\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(vectors: Vector1D[], direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach(v => v.add(loopDistance))\n  }\n\n  const self: ScrollLooper = {\n    loop,\n  }\n  return self\n}\n","import { Counter } from './counter'\nimport { Limit } from './limit'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  index: Counter\n  loop: boolean\n  scrollSnaps: number[]\n  contentSize: number\n  limit: Limit\n  target: Vector1D\n}\n\nexport type Target = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTarget = {\n  byIndex: (target: number, direction: number) => Target\n  byDistance: (force: number, snap: boolean) => Target\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(params: Params): ScrollTarget {\n  const { loop, limit, scrollSnaps, contentSize } = params\n  const { reachedMax, reachedAny, removeOffset } = limit\n\n  function minDistance(d1: number, d2: number): number {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2\n  }\n\n  function findTargetSnap(target: number): Target {\n    const distance = removeOffset(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map(scrollSnap => scrollSnap - distance)\n      .map(diffToSnap => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => Math.abs(d1.diff) - Math.abs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const t1 = target\n    const t2 = target + contentSize\n    const t3 = target - contentSize\n\n    if (!loop) return t1\n    if (!direction) return minDistance(minDistance(t1, t2), t3)\n\n    const shortest = minDistance(t1, direction === 1 ? t2 : t3)\n    return Math.abs(shortest) * direction\n  }\n\n  function findTargetIndex(target: number, index: number): number {\n    const reachedBound = !loop && reachedAny(target)\n    if (!reachedBound) return index\n\n    const { min, max } = params.index\n    return reachedMax(target) ? min : max\n  }\n\n  function byIndex(index: number, direction: number): Target {\n    const diffToSnap = scrollSnaps[index] - params.target.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): Target {\n    const target = params.target.get() + distance\n    const targetSnap = findTargetSnap(target)\n    const index = findTargetIndex(target, targetSnap.index)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnap.distance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTarget = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { Axis } from './axis'\nimport { arrayKeys } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  scrollSnaps: number[]\n  viewSize: number\n  location: Vector1D\n  slideSizes: number[]\n  contentSize: number\n}\n\ntype LoopPoint = {\n  point: number\n  location: number\n  index: number\n  getTarget: (location: number) => number\n}\n\nexport type SlideLooper = {\n  canLoop: () => boolean\n  clear: (slides: HTMLElement[]) => void\n  loop: (slides: HTMLElement[]) => void\n  loopPoints: LoopPoint[]\n}\n\nexport function SlideLooper(params: Params): SlideLooper {\n  const { axis, location: containerLocation } = params\n  const { contentSize, viewSize, slideSizes, scrollSnaps } = params\n  const ascItems = arrayKeys(slideSizes)\n  const descItems = arrayKeys(slideSizes).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n  const loopStyle = axis.scroll === 'x' ? 'left' : 'top'\n\n  function subtractItemSizes(\n    indexes: number[],\n    from: number,\n  ): number {\n    return indexes.reduce((a: number, i) => {\n      const size = slideSizes[i]\n      return a - size\n    }, from)\n  }\n\n  function loopItemsIn(\n    sizeOfGap: number,\n    indexes: number[],\n  ): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const gapLeft = subtractItemSizes(a, sizeOfGap)\n      return gapLeft > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function loopStart(\n    sizeOfGap: number,\n    indexes: number[],\n    from: number,\n  ): number {\n    return indexes.reduce((a: number, i) => {\n      const gapFilled = a + slideSizes[i]\n      return gapFilled < sizeOfGap ? gapFilled : a\n    }, from)\n  }\n\n  function loopPointFor(\n    indexes: number[],\n    from: number,\n    direction: 0 | 1,\n  ): number {\n    const slideCount = ascItems.length - 1\n    return subtractItemSizes(\n      indexes.map(i => (i + direction) % slideCount),\n      from,\n    )\n  }\n\n  function loopPointsFor(\n    indexes: number[],\n    from: number,\n    direction: 0 | 1,\n  ): LoopPoint[] {\n    const ascIndexes = indexes.slice().sort((a, b) => a - b)\n    return ascIndexes.map(\n      (index, loopIndex): LoopPoint => {\n        const initial = contentSize * (!direction ? 0 : -1)\n        const offset = contentSize * (!direction ? 1 : 0)\n        const slidesInSpan = ascIndexes.slice(0, loopIndex)\n        const point = loopPointFor(slidesInSpan, from, direction)\n        const getTarget = (location: number): number =>\n          location > point ? initial : offset\n        return { point, getTarget, index, location: -1 }\n      },\n    )\n  }\n\n  function startPoints(): LoopPoint[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = loopItemsIn(gap, descItems)\n    const start = loopStart(gap, indexes, 0)\n    return loopPointsFor(indexes, start, 1)\n  }\n\n  function endPoints(): LoopPoint[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = loopItemsIn(gap, ascItems)\n    const start = loopStart(contentSize, ascItems, -viewSize)\n    return loopPointsFor(indexes, -start, 0)\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter(i => i !== index)\n      return subtractItemSizes(otherIndexes, viewSize) <= 0\n    })\n  }\n\n  function loop(slides: HTMLElement[]): void {\n    loopPoints.forEach(loopPoint => {\n      const { getTarget, location, index } = loopPoint\n      const target = getTarget(containerLocation.get())\n      if (target !== location) {\n        slides[index].style[loopStyle] = `${target}%`\n        loopPoint.location = target\n      }\n    })\n  }\n\n  function clear(slides: HTMLElement[]): void {\n    loopPoints.forEach(({ index }) => {\n      slides[index].style[loopStyle] = ''\n    })\n  }\n\n  const self: SlideLooper = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { arrayKeys } from './utils'\n\ntype Params = {\n  contentSize: number\n  slideSizes: number[]\n  viewSize: number\n  loop: boolean\n  inViewThreshold: number\n}\n\ntype SlidePoint = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInView = {\n  check: (location: number) => number[]\n}\n\nexport function SlidesInView(params: Params): SlidesInView {\n  const { contentSize, slideSizes, viewSize } = params\n  const { inViewThreshold, loop } = params\n  const thresholds = slideSizes.map(s => s * inViewThreshold)\n  const scrollSnaps = arrayKeys(slideSizes).map(scrollSnap)\n  const pointsToCheck = concatSlidePoints()\n\n  function scrollSnap(index: number): number {\n    const span = slideSizes.slice(0, index)\n    return span.reduce((a, s) => a - s, 0)\n  }\n\n  function concatSlidePoints(): SlidePoint[] {\n    const offsets = loop ? [0, contentSize, -contentSize] : [0]\n    return offsets.map(slidePoints).reduce((a, b) => a.concat(b), [])\n  }\n\n  function slidePoints(offset: number): SlidePoint[] {\n    return scrollSnaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + thresholds[index] + offset,\n      end: snap + viewSize - thresholds[index] + offset,\n      index,\n    }))\n  }\n\n  function check(location: number): number[] {\n    return pointsToCheck.reduce((list: number[], point) => {\n      const { index, start, end } = point\n      const inList = list.indexOf(index) !== -1\n      const inView = start < location && end > location\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInView = {\n    check,\n  }\n  return self\n}\n","import { Axis } from './axis'\nimport { roundToDecimals } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  container: HTMLElement\n}\n\nexport type Translate = {\n  clear: () => void\n  to: (vector: Vector1D) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(params: Params): Translate {\n  const { axis, container } = params\n  const translates = { x, y }\n  const translateAxis = translates[axis.scroll]\n  const roundToTwoDecimals = roundToDecimals(2)\n  const containerStyle = container.style\n  let disabled = false\n  let location = 0\n\n  function x(n: number): string {\n    return `translate3d(${n}%,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}%,0px)`\n  }\n\n  function to(v: Vector1D): void {\n    if (disabled) return\n    const target = roundToTwoDecimals(v.get())\n\n    if (location !== target) {\n      getComputedStyle(container).transform\n      containerStyle.transform = translateAxis(target)\n      location = target\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    containerStyle.transform = ''\n    location = 0\n  }\n\n  const self: Translate = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Animation } from './animation'\nimport { Axis } from './axis'\nimport { Counter } from './counter'\nimport { DragHandler } from './dragHandler'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitter } from './eventEmitter'\nimport { Limit } from './limit'\nimport { Options } from './options'\nimport { PxToPercent } from './pxToPercent'\nimport { ScrollBody } from './scrollBody'\nimport { ScrollBounds } from './scrollBounds'\nimport { ScrollContain } from './scrollContain'\nimport { ScrollLimit } from './scrollLimit'\nimport { ScrollLooper } from './scrollLooper'\nimport { ScrollProgress } from './scrollProgress'\nimport { ScrollSnap } from './scrollSnap'\nimport { ScrollTarget } from './scrollTarget'\nimport { ScrollTo } from './scrollTo'\nimport { SlideLooper } from './slideLooper'\nimport { SlidesInView } from './slidesInView'\nimport { Translate } from './translate'\nimport { arrayKeys, groupArray } from './utils'\nimport { Vector1D } from './vector1d'\n\nexport type Engine = {\n  axis: Axis\n  animation: Animation\n  scrollBounds: ScrollBounds\n  scrollLooper: ScrollLooper\n  scrollProgress: ScrollProgress\n  index: Counter\n  indexPrevious: Counter\n  limit: Limit\n  location: Vector1D\n  options: Options\n  pxToPercent: PxToPercent\n  scrollBody: ScrollBody\n  dragHandler: DragHandler\n  slideLooper: SlideLooper\n  slidesInView: SlidesInView\n  target: Vector1D\n  translate: Translate\n  scrollTo: ScrollTo\n  scrollTarget: ScrollTarget\n  scrollSnaps: number[]\n  snapIndexes: number[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: Options,\n  events: EventEmitter,\n): Engine {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll,\n    containScroll,\n  } = options\n\n  // Measurements\n  const axis = Axis(scrollAxis)\n  const pxToPercent = PxToPercent(axis.measure(container))\n  const viewSize = pxToPercent.totalPercent\n  const slideSizes = slides.map(axis.measure).map(pxToPercent.measure)\n  const groupedSizes = groupArray(slideSizes, slidesToScroll)\n  const snapSizes = groupedSizes.map(g => g.reduce((a, s) => a + s))\n  const snapIndexes = arrayKeys(snapSizes)\n  const contentSize = slideSizes.reduce((a, s) => a + s, 0)\n  const alignment = Alignment({ align, viewSize })\n  const scrollSnap = ScrollSnap({ snapSizes, alignment, loop })\n  const defaultSnaps = snapIndexes.map(scrollSnap.measure)\n  const contain = ScrollContain({ alignment, contentSize, viewSize })\n  const shouldContain = !loop && containScroll !== ''\n  const trimSnaps = containScroll === 'trimSnaps'\n  const containedSnaps = contain.measure(defaultSnaps, trimSnaps)\n  const scrollSnaps = shouldContain ? containedSnaps : defaultSnaps\n\n  // Index\n  const indexSpan = Limit({ min: 0, max: scrollSnaps.length - 1 })\n  const index = Counter({ limit: indexSpan, start: startIndex, loop })\n  const indexPrevious = index.clone()\n\n  // ScrollLimit\n  const scrollLimit = ScrollLimit({ loop, contentSize })\n  const limit = scrollLimit.measure(scrollSnaps)\n\n  // Draw\n  const update = (): void => {\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (!dragHandler.pointerDown()) {\n      if (!loop) engine.scrollBounds.constrain(target)\n      if (settled) {\n        engine.animation.stop()\n        events.emit('settle')\n      }\n    }\n    if (loop) {\n      const direction = engine.scrollBody.direction.get()\n      engine.scrollLooper.loop(loopVectors, direction)\n      engine.slideLooper.loop(slides)\n    }\n\n    if (!settled) events.emit('scroll')\n    engine.translate.to(engine.scrollBody.location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const loopVectors = [location, target]\n  const scrollBody = ScrollBody({ location, speed, mass: 1 })\n  const scrollTarget = ScrollTarget({\n    contentSize,\n    index,\n    limit,\n    loop,\n    scrollSnaps,\n    target,\n  })\n  const scrollTo = ScrollTo({\n    animation,\n    events,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n  })\n\n  // DragHandler\n  const dragHandler = DragHandler({\n    animation,\n    axis,\n    dragFree,\n    dragTracker: DragTracker({\n      axis,\n      pxToPercent,\n    }),\n    element: root,\n    events,\n    index,\n    limit,\n    location,\n    loop,\n    scrollBody,\n    scrollTo,\n    scrollTarget,\n    target,\n  })\n\n  // Slider\n  const engine: Engine = {\n    animation,\n    axis,\n    dragHandler,\n    pxToPercent,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds({\n      animation,\n      limit,\n      location,\n      scrollBody,\n    }),\n    scrollLooper: ScrollLooper({\n      contentSize,\n      limit,\n      location,\n      pxToPercent,\n    }),\n    scrollProgress: ScrollProgress({\n      limit,\n    }),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper({\n      axis,\n      contentSize,\n      location,\n      scrollSnaps,\n      slideSizes,\n      viewSize,\n    }),\n    slidesInView: SlidesInView({\n      contentSize,\n      inViewThreshold,\n      loop,\n      slideSizes,\n      viewSize,\n    }),\n    snapIndexes,\n    target,\n    translate: Translate({\n      axis,\n      container,\n    }),\n  }\n  return engine\n}\n","import { Limit } from './limit'\r\n\r\ntype Params = {\r\n  limit: Limit\r\n}\r\n\r\nexport type ScrollProgress = {\r\n  get: (n: number) => number\r\n}\r\n\r\nexport function ScrollProgress(params: Params): ScrollProgress {\r\n  const { max, length: scrollLength } = params.limit\r\n\r\n  function get(n: number): number {\r\n    const currentLocation = n - max\r\n    return currentLocation / -scrollLength\r\n  }\r\n\r\n  const self: ScrollProgress = {\r\n    get,\r\n  }\r\n  return self\r\n}\r\n","export type AxisOption = 'x' | 'y'\n\nexport type Axis = {\n  cross: AxisOption\n  scroll: AxisOption\n  measure: (node: HTMLElement) => number\n}\n\nexport function Axis(axis: AxisOption): Axis {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n\n  function measure(node: HTMLElement): number {\n    const { width, height } = node.getBoundingClientRect()\n    return scroll === 'x' ? width : height\n  }\n\n  const self: Axis = {\n    cross,\n    measure,\n    scroll,\n  }\n  return self\n}\n","export type PxToPercent = {\n  measure: (n: number) => number\n  totalPercent: number\n}\n\nexport function PxToPercent(viewInPx: number): PxToPercent {\n  const totalPercent = 100\n\n  function measure(n: number): number {\n    return (n / viewInPx) * totalPercent\n  }\n\n  const self: PxToPercent = {\n    measure,\n    totalPercent,\n  }\n  return Object.freeze(self)\n}\n","import { Alignment } from './alignment'\nimport { Counter } from './counter'\nimport { Limit } from './limit'\n\ntype Params = {\n  snapSizes: number[]\n  alignment: Alignment\n  loop: boolean\n}\n\nexport type ScrollSnap = {\n  measure: (index: number) => number\n}\n\nexport function ScrollSnap(params: Params): ScrollSnap {\n  const { snapSizes, alignment, loop } = params\n  const alignments = snapSizes.map(alignment.measure)\n  const distancesBetween = distancesBetweenScrollSnaps()\n\n  function distancesBetweenScrollSnaps(): number[] {\n    const limit = Limit({ min: 0, max: snapSizes.length - 1 })\n    const counter = Counter({ limit, start: 0, loop })\n\n    return snapSizes.map((size, index) => {\n      const next = counter.set(index + 1).get()\n      return size + alignments[index] - alignments[next]\n    })\n  }\n\n  function measure(index: number): number {\n    const sizes = distancesBetween.slice(0, index)\n    return sizes.reduce((a, s) => a - s, alignments[0])\n  }\n\n  const self: ScrollSnap = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\n\ntype Params = {\n  contentSize: number\n  loop: boolean\n}\n\nexport type ScrollLimit = {\n  measure: (scrollSnaps: number[]) => Limit\n}\n\nexport function ScrollLimit(params: Params): ScrollLimit {\n  const { contentSize, loop } = params\n\n  function measure(scrollSnaps: number[]): Limit {\n    const startSnap = scrollSnaps[0]\n    const endSnap = scrollSnaps[scrollSnaps.length - 1]\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit({ min, max })\n  }\n\n  const self: ScrollLimit = {\n    measure,\n  }\n  return self\n}\n","type Callback = () => void\n\nexport type Animation = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): Animation {\n  const run = requestAnimationFrame.bind(window)\n  const end = cancelAnimationFrame.bind(window)\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: Callback): Callback {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = run(callback)\n  }\n\n  function stop(): void {\n    end(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: Animation = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Counter } from './counter'\nimport { EventEmitter } from './eventEmitter'\nimport { ScrollTarget, Target } from './scrollTarget'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  animation: Animation\n  target: Vector1D\n  index: Counter\n  indexPrevious: Counter\n  scrollTarget: ScrollTarget\n  events: EventEmitter\n}\n\nexport type ScrollTo = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(params: Params): ScrollTo {\n  const { index: indexCurrent, scrollTarget, animation } = params\n  const { indexPrevious, events, target: targetDistance } = params\n\n  function scrollTo(target: Target): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetDistance.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      events.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollTo = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { AlignmentOption } from './alignment'\nimport { AxisOption } from './axis'\nimport { ScrollContainOption } from './scrollContain'\n\nexport type Options = {\n  align: AlignmentOption\n  axis: AxisOption\n  containScroll: ScrollContainOption\n  containerSelector: string\n  dragFree: boolean\n  draggable: boolean\n  draggableClass: string\n  draggingClass: string\n  inViewThreshold: number\n  loop: boolean\n  selectedClass: string\n  slidesToScroll: number\n  speed: number\n  startIndex: number\n}\n\nexport const defaultOptions: Options = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  containerSelector: '*',\n  dragFree: false,\n  draggable: true,\n  draggableClass: 'is-draggable',\n  draggingClass: 'is-dragging',\n  inViewThreshold: 0,\n  loop: false,\n  selectedClass: 'is-selected',\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0,\n}\n\nexport type EmblaOptions = Partial<Options>\n","import { Engine } from './components/engine'\nimport { EventEmitter, EmblaEvent } from './components/eventEmitter'\nimport { EventStore } from './components/eventStore'\nimport { defaultOptions, EmblaOptions } from './components/options'\nimport {\n  addClass,\n  arrayFromCollection,\n  debounce,\n  removeClass,\n} from './components/utils'\n\nexport type EmblaCarousel = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  dangerouslyGetEngine: () => Engine\n  destroy: () => void\n  off: EventEmitter['off']\n  on: EventEmitter['on']\n  previousScrollSnap: () => number\n  reInit: (options: EmblaOptions) => void\n  scrollNext: () => void\n  scrollPrev: () => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  sliderRoot: HTMLElement,\n  userOptions: EmblaOptions = {},\n): EmblaCarousel {\n  const events = EventEmitter()\n  const eventStore = EventStore()\n  const debouncedResize = debounce(resize, 500)\n  const reInit = reActivate\n  const { on, off } = events\n\n  let engine: Engine\n  let activated = false\n  let options = Object.assign({}, defaultOptions)\n  let containerSize = 0\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  activate(userOptions)\n\n  function storeElements(): void {\n    if (!sliderRoot) throw new Error('Missing root node 😢')\n\n    const selector = options.containerSelector\n    const sliderContainer = sliderRoot.querySelector(selector)\n\n    if (!sliderContainer) throw new Error('Missing container node 😢')\n\n    container = sliderContainer as HTMLElement\n    slides = arrayFromCollection(container.children)\n  }\n\n  function activate(partialOptions: EmblaOptions = {}): void {\n    storeElements()\n    options = Object.assign(options, partialOptions)\n    engine = Engine(sliderRoot, container, slides, options, events)\n\n    const {\n      axis,\n      scrollBody,\n      translate,\n      dragHandler,\n      slideLooper,\n    } = engine\n    const {\n      loop,\n      draggable,\n      draggableClass,\n      selectedClass,\n      draggingClass,\n    } = options\n\n    containerSize = axis.measure(container)\n    eventStore.add(window, 'resize', debouncedResize)\n    translate.to(scrollBody.location)\n    slides.forEach(slideFocusEvent)\n    dragHandler.addActivationEvents()\n\n    if (loop) {\n      if (!slideLooper.canLoop()) return reActivate({ loop: false })\n      slideLooper.loop(slides)\n    }\n    if (draggable) {\n      if (draggableClass) {\n        addClass(sliderRoot, draggableClass)\n      }\n      if (draggingClass) {\n        events.on('pointerDown', toggleDraggingClass)\n        events.on('pointerUp', toggleDraggingClass)\n      }\n    } else {\n      events.on('pointerDown', dragHandler.removeInteractionEvents)\n    }\n    if (selectedClass) {\n      toggleSelectedClass()\n      events.on('select', toggleSelectedClass)\n      events.on('pointerUp', toggleSelectedClass)\n    }\n    if (!activated) {\n      setTimeout(() => events.emit('init'), 0)\n      activated = true\n    }\n  }\n\n  function toggleDraggingClass(evt: EmblaEvent): void {\n    const { draggingClass } = options\n    if (evt === 'pointerDown') addClass(sliderRoot, draggingClass)\n    else removeClass(sliderRoot, draggingClass)\n  }\n\n  function toggleSelectedClass(): void {\n    const { selectedClass } = options\n    const inView = slidesInView(true)\n    const notInView = slidesNotInView(true)\n    notInView.forEach(i => removeClass(slides[i], selectedClass))\n    inView.forEach(i => addClass(slides[i], selectedClass))\n  }\n\n  function slideFocusEvent(slide: HTMLElement, index: number): void {\n    const focus = (): void => {\n      const groupIndex = Math.floor(index / options.slidesToScroll)\n      const selectedGroup = index ? groupIndex : index\n      sliderRoot.scrollLeft = 0\n      scrollTo(selectedGroup)\n    }\n    eventStore.add(slide, 'focus', focus, true)\n  }\n\n  function reActivate(partialOptions: EmblaOptions = {}): void {\n    const startIndex = engine.index.get()\n    const newOptions = Object.assign({ startIndex }, partialOptions)\n    deActivate()\n    activate(newOptions)\n    events.emit('reInit')\n  }\n\n  function deActivate(): void {\n    const { selectedClass, draggableClass } = options\n    engine.dragHandler.removeActivationEvents()\n    engine.dragHandler.removeInteractionEvents()\n    engine.animation.stop()\n    eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear(slides)\n    removeClass(sliderRoot, draggableClass)\n    slides.forEach(s => removeClass(s, selectedClass))\n    events.off('select', toggleSelectedClass)\n    events.off('pointerUp', toggleSelectedClass)\n    events.off('pointerDown', toggleDraggingClass)\n    events.off('pointerUp', toggleDraggingClass)\n  }\n\n  function destroy(): void {\n    if (!activated) return\n    deActivate()\n    activated = false\n    engine = {} as Engine\n    events.emit('destroy')\n  }\n\n  function resize(): void {\n    const newContainerSize = engine.axis.measure(container)\n    if (containerSize !== newContainerSize) reActivate()\n    events.emit('resize')\n  }\n\n  function slidesInView(target = false): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target = false): number[] {\n    const inView = slidesInView(target)\n    return engine.snapIndexes.filter(i => inView.indexOf(i) === -1)\n  }\n\n  function scrollSnapList(): number[] {\n    const getScrollProgress = engine.scrollProgress.get\n    return engine.scrollSnaps.map(getScrollProgress)\n  }\n\n  function scrollTo(index: number): void {\n    engine.scrollBody.useDefaultMass().useDefaultSpeed()\n    engine.scrollTo.index(index, 0)\n  }\n\n  function scrollNext(): void {\n    const next = engine.index.clone().add(1)\n    engine.scrollBody.useDefaultMass().useDefaultSpeed()\n    engine.scrollTo.index(next.get(), -1)\n  }\n\n  function scrollPrev(): void {\n    const prev = engine.index.clone().add(-1)\n    engine.scrollBody.useDefaultMass().useDefaultSpeed()\n    engine.scrollTo.index(prev.get(), 1)\n  }\n\n  function canScrollPrev(): boolean {\n    const { index } = engine\n    return options.loop || index.get() !== index.min\n  }\n\n  function canScrollNext(): boolean {\n    const { index } = engine\n    return options.loop || index.get() !== index.max\n  }\n\n  function scrollProgress(): number {\n    const location = engine.location.get()\n    return engine.scrollProgress.get(location)\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function dangerouslyGetEngine(): Engine {\n    return engine\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarousel = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    dangerouslyGetEngine,\n    destroy,\n    off,\n    on,\n    previousScrollSnap,\n    reInit,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n  return self\n}\n\nexport default EmblaCarousel\n","type Callback = (evt: EmblaEvent) => void\ntype Listeners = { [key in EmblaEvent]: Callback[] }\n\nexport type EmblaEvent =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventEmitter = {\n  emit: (evt: EmblaEvent) => EventEmitter\n  on: (evt: EmblaEvent, cb: Callback) => EventEmitter\n  off: (evt: EmblaEvent, cb: Callback) => EventEmitter\n}\n\nexport function EventEmitter(): EventEmitter {\n  const listeners: Listeners = {\n    destroy: [],\n    pointerDown: [],\n    pointerUp: [],\n    init: [],\n    reInit: [],\n    resize: [],\n    scroll: [],\n    select: [],\n    settle: [],\n  }\n\n  function emit(evt: EmblaEvent): EventEmitter {\n    listeners[evt].forEach(e => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEvent, cb: Callback): EventEmitter {\n    listeners[evt] = listeners[evt].concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEvent, cb: Callback): EventEmitter {\n    listeners[evt] = listeners[evt].filter(e => e !== cb)\n    return self\n  }\n\n  const self: EventEmitter = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n"],"names":["Alignment","params","viewSize","align","predefined","start","center","n","end","measure","Number","Counter","limit","loop","min","max","type","counter","withinLimit","get","set","self","add","sign","Math","abs","clone","Vector1D","value","vector","divide","readNumber","multiply","normalize","subtract","Direction","direction","v","d","EventStore","listeners","node","handler","options","addEventListener","push","removeEventListener","removeAll","filter","remove","length","DragHandler","target","scrollBody","dragFree","animation","axis","element","dragTracker","location","events","scrollAxis","crossAxis","focusNodes","startScroll","startCross","dragStartPoint","activationEvents","interactionEvents","removeActivationEvents","removeInteractionEvents","snapForceBoost","mouse","touch","freeForceBoost","snapSpeed","freeSpeed","pointerIsDown","preventScroll","preventClick","isMouse","down","evt","button","name","isMoving","delta","clearPreventClick","isNotFocusNode","nodeName","indexOf","preventDefault","pointerDown","useDefaultMass","useSpeed","document","move","up","addInteractionEvents","readPoint","emit","moveScroll","moveCross","diffScroll","diffCross","diff","pointerMove","reachedLimit","reachedAny","resist","force","pointerUp","scrollTo","scrollTarget","index","seekNext","byDistance","distance","indexDiff","next","seekTargetBy","pointB","pointA","click","addActivationEvents","clickAllowed","DragTracker","pxToPercent","coords","x","y","startDrag","diffDrag","lastDrag","pointValue","trackPoints","trackTime","Date","getTime","touches","c","point","time2","currentPoint","trackLength","slice","map","trackPoint","sort","p1","p2","Limit","loopLimits","constrainLimits","reachedMin","reachedMax","reachedWhich","constrain","which","removeOffset","roundToDecimals","decimalPoints","pow","round","arrayKeys","array","Object","keys","removeClass","className","cl","classList","contains","addClass","ScrollBody","speed","mass","roundToTwoDecimals","velocity","acceleration","attraction","state","useMass","seek","iStart","iStop","oStart","oStop","magnitude","m","applyForce","settle","hasSettled","update","useDefaultSpeed","ScrollBounds","disabled","timeout","shouldConstrain","window","setTimeout","constraint","toggleActive","active","ScrollContain","alignment","contentSize","scrollBounds","alignedWithinView","contentExceedsView","scrollSnaps","trim","containedSnaps","_a","startSnap","endSnap","lastIndexOf","findDuplicates","ScrollLooper","vectors","shouldLoop","loopDistance","forEach","ScrollTarget","minDistance","d1","d2","shortcut","t1","t2","t3","shortest","snap","targetSnap","scrollSnap","diffToSnap","i","findTargetSnap","findTargetIndex","reachedBound","byIndex","SlideLooper","gap","indexes","containerLocation","slideSizes","ascItems","descItems","reverse","loopPoints","loopItemsIn","loopStart","loopPointsFor","concat","endPoints","loopStyle","scroll","subtractItemSizes","from","reduce","a","sizeOfGap","gapFilled","ascIndexes","b","loopIndex","initial","offset","slideCount","loopPointFor","getTarget","canLoop","every","clear","slides","style","loopPoint","SlidesInView","inViewThreshold","thresholds","s","pointsToCheck","slidePoints","check","list","Translate","container","translateAxis","containerStyle","transform","to","getComputedStyle","Engine","root","scrollLength","startIndex","slidesToScroll","containScroll","cross","getBoundingClientRect","width","height","Axis","viewInPx","totalPercent","freeze","PxToPercent","snapSizes","size","groups","groupArray","g","snapIndexes","alignments","distancesBetween","ScrollSnap","defaultSnaps","contain","shouldContain","trimSnaps","indexPrevious","ScrollLimit","callback","run","requestAnimationFrame","bind","cancelAnimationFrame","animationFrame","ifAnimating","cb","proceed","stop","Animation","engine","settled","dragHandler","scrollLooper","loopVectors","slideLooper","translate","startLocation","indexCurrent","targetDistance","distanceDiff","targetIndex","ScrollTo","scrollProgress","slidesInView","defaultOptions","containerSelector","draggable","draggableClass","draggingClass","selectedClass","sliderRoot","userOptions","time","destroy","init","reInit","resize","select","e","off","on","EventEmitter","eventStore","debouncedResize","newContainerSize","containerSize","reActivate","id","clearTimeout","activated","_extends","storeElements","Error","nodeList","selector","sliderContainer","querySelector","children","Array","prototype","call","activate","partialOptions","slideFocusEvent","toggleDraggingClass","toggleSelectedClass","inView","slidesNotInView","slide","groupIndex","floor","selectedGroup","scrollLeft","newOptions","deActivate","canScrollNext","canScrollPrev","containerNode","dangerouslyGetEngine","previousScrollSnap","scrollNext","scrollPrev","prev","scrollSnapList","getScrollProgress","selectedScrollSnap","slideNodes"],"mappings":"4ZAWgBA,EAAUC,OAChBC,EAAoBD,WAAVE,EAAUF,QACtBG,EAAa,CAAEC,wBAGZ,GAHmBC,gBAMZC,UACNL,EAAWK,GAAK,GAPUC,aAUvBD,UACJL,EAAWK,UAYI,CACtBE,iBANeF,SACM,iBAAVJ,EAJJD,EAAWQ,OAAOP,GAKlBC,EAAWD,GAAOI,cChBbI,EAAQV,OACdI,EAAuBJ,QAAhBW,EAAgBX,QAATY,EAASZ,OACvBa,EAAaF,MAARG,EAAQH,MACfI,EAAOH,EAAO,OAAS,YACzBI,EAAUC,EAAYb,YAEjBc,WACAF,WAGAG,EAAIb,UACXU,EAAUC,EAAYX,GACfc,WAGAH,EAAYX,UACZK,EAAMI,GAAMT,OAgBfc,EAAgB,CACpBC,aAdOA,EAAIf,MACD,IAANA,EAAS,KACLgB,EAAOhB,EAAIiB,KAAKC,IAAIlB,UAC1Ba,EAAID,IAAQI,GACLD,EAAIf,GAAY,EAARgB,UAEVF,GASPK,wBALOf,EAAQ,CAAEN,MAAOc,IAAOP,QAAOC,UAMtCM,MACAJ,MACAD,MACAM,cAEKC,WC/COM,EAASC,OACnBC,EAASD,WA0BJE,EAAOvB,UACdsB,GAAUtB,EACHc,WAQAU,EAAWxB,SACE,iBAANA,EAAiBA,EAAIA,EAAEY,UAGjCE,EAAiB,CACrBC,aA9BWf,UACXsB,GAAUE,EAAWxB,GACdc,GA6BPS,SACAX,sBAxCOU,GAyCPG,kBAvBgBzB,UAChBsB,GAAUtB,EACHc,GAsBPY,4BAbe,IAAXJ,GAAcC,EAAOD,GAClBR,GAaPD,aAxCWb,UACXsB,EAASE,EAAWxB,GACbc,GAuCPa,kBA/BgB3B,UAChBsB,GAAUE,EAAWxB,GACdc,WA+BFA,WCrDOc,EAAUP,OAClBQ,EAAYT,EAASM,EAAUL,aAG5BK,EAAU1B,UACJ,IAANA,EAAU,EAAIA,EAAIiB,KAAKC,IAAIlB,OAS9Bc,EAAkB,CACtBF,IAbciB,MAcdhB,aARWiB,OACLC,EAAIL,EAAUI,EAAElB,cACZ,IAANmB,GAASF,EAAUhB,IAAIkB,GACpBjB,WAOFA,WCXOkB,QACRC,EAA4B,OAqB5BnB,EAAmB,CACvBC,aAnBAmB,EACAzB,EACA0B,EACAC,uBAAAA,MAEAF,EAAKG,iBAAiB5B,EAAM0B,EAASC,GACrCH,EAAUK,MAAK,kBACNJ,EAAKK,oBAAoB9B,EAAM0B,EAASC,MAE1CtB,GAWP0B,4BAPAP,EAAUQ,QAAO,SAAAC,UAAUA,OAC3BT,EAAUU,OAAS,EACZ7B,WAOFA,WCFO8B,EAAYlD,OAClBmD,EAAkDnD,SAA1CoD,EAA0CpD,aAA9BqD,EAA8BrD,WAApBsD,EAAoBtD,YAATuD,EAASvD,OAClDwD,EAAkDxD,UAAzCyD,EAAyCzD,cAA5B0D,EAA4B1D,WAAlB2D,EAAkB3D,SAAVW,EAAUX,QAC1C4D,EAAiCL,SAAdM,EAAcN,QAC3CO,EAAa,CAAC,QAAS,SAAU,YACjCC,EAAcrC,EAAS,GACvBsC,EAAatC,EAAS,GACtBuC,EAAiBvC,EAAS,GAC1BwC,EAAmB5B,IACnB6B,EAAoB7B,IACpB8B,EAAyBF,EAAiBpB,UAC1CuB,EAA0BF,EAAkBrB,UAC5CwB,EAAiB,CAAEC,MAAO,IAAKC,MAAO,KACtCC,EAAiB,CAAEF,MAAO,EAAGC,MAAO,GACpCE,EAAY,CAAEH,MAAO,GAAIC,MAAO,IAChCG,EAAY,CAAEJ,MAAO,EAAGC,MAAO,GAEjCI,GAAgB,EAChBC,GAAgB,EAChBC,GAAe,EACfC,GAAU,WAwDLC,EAAKC,QACZF,EAAuB,cAAbE,EAAIlE,OACgC,IAA9BkE,EAAmBC,YAnChB1C,EACb2C,EAoCAC,EAAWC,EAAMlC,EAAOjC,MAAOwC,EAASxC,QAAU,EAClDoE,EAAoBP,IAAYK,EAChCG,GAvCa/C,EAuCiByC,EAAI9B,OAtClCgC,EAAO3C,EAAKgD,UAAY,KACvB1B,EAAW2B,QAAQN,IAAS,IAsC7BO,EAAiBN,GAAaL,GAAWQ,EAE/CX,GAAgB,EAChBnB,EAAYkC,YAAYV,GACxBhB,EAAe9C,IAAIgC,GACnBA,EAAOhC,IAAIuC,GACXN,EAAWwC,iBAAiBC,SAAS,mBAtD/BrD,EAAQuC,EAAoBe,SAAVtC,EACxBW,EACG9C,IAAImB,EAAM,YAAauD,GACvB1E,IAAImB,EAAM,WAAYwD,GACtB3E,IAAImB,EAAM,YAAauD,GACvB1E,IAAImB,EAAM,UAAWwD,GAkDxBC,GACAlC,EAAY5C,IAAIsC,EAAYyC,UAAUjB,EAAKrB,IAC3CI,EAAW7C,IAAIsC,EAAYyC,UAAUjB,EAAKpB,IAC1CF,EAAOwC,KAAK,eAERb,IAAmBR,GAAe,GAClCY,GAAgBT,EAAIS,2BAGjBK,EAAKd,OACPJ,IAAkBE,EAAS,KACxBqB,EAAa3C,EAAYyC,UAAUjB,EAAKrB,GAAY1C,MACpDmF,EAAY5C,EAAYyC,UAAUjB,EAAKpB,GAAW3C,MAClDoF,EAAajB,EAAMe,EAAYrC,EAAY7C,OAC3CqF,EAAYlB,EAAMgB,EAAWrC,EAAW9C,YAC9C2D,EAAgByB,EAAaC,KACNzB,EAAc,OAAOkB,QAExCQ,EAAO/C,EAAYgD,YAAYxB,GAC/ByB,EAAe/F,EAAMgG,WAAWjD,EAASxC,OACzC0F,GAAU5G,EAAOY,MAAQ8F,EAAe,EAAI,GAE7C5B,GAAgB0B,IAAM1B,GAAe,GAC1CxB,EAAUlD,QACV+C,EAAO9B,IAAImF,EAAOI,GAClB3B,EAAIS,0BAGGM,QACDa,EAAQpD,EAAYqD,aAhEZzD,EAAWoB,EAAiBH,GAC7BS,EAAU,QAAU,SAgEhBM,EAAMlC,EAAOjC,MAAO+C,EAAe/C,QAAU,KAE7C6D,IAASD,GAAe,GACzCC,GAAU,EACVF,GAAgB,EAChBD,GAAgB,EAChBT,EAAkBrB,YAClBM,EAAWyC,UA9EGxC,EAAWsB,EAAYD,GACxBK,EAAU,QAAU,mBAUb8B,OACZE,EAAkC/G,WAAxBgH,EAAwBhH,eAAViH,EAAUjH,QACpC0G,EAAe/F,EAAMgG,WAAWxD,EAAOjC,MAAQ2F,GAG/CK,IAFkBF,EAAaG,WAAW,GAAG,GACbF,QAAUA,EAAM/F,QACnBK,KAAKC,IAAIqF,GAjDxB,KAmDfxD,GAAaqD,IAAgBQ,EAKhCH,EAASK,SAASP,GAAQxD,OALgB,KACpCgE,GAAsC,EAA1BnF,EAAU2E,GAAO3F,MAC7BoG,EAAOL,EAAMxF,QAAQJ,IAAIgG,GAC/BN,EAASE,MAAMK,EAAKpG,MAAO,IA0D7BqG,CAAaV,GACblD,EAAOwC,KAAK,sBAGLd,EAAMmC,EAAgBC,UACtBlG,KAAKC,IAAIgG,EAASC,YAGlBC,EAAMzC,GACTH,GAAcG,EAAIS,uBAWE,CACxBiC,mCA9HMnF,EAAOgB,EACbU,EACG7C,IAAImB,EAAM,aAAa,eACvBnB,IAAImB,EAAM,YAAY,eACtBnB,IAAImB,EAAM,aAAcwC,GACxB3D,IAAImB,EAAM,YAAawC,GACvB3D,IAAImB,EAAM,cAAewD,GACzB3E,IAAImB,EAAM,cAAewD,GACzB3E,IAAImB,EAAM,QAASkF,IAuHtBE,+BATQ9C,GAURa,8BANOf,GAOPR,yBACAC,oCC/KYwD,EAAY7H,OAClBuD,EAAsBvD,OAAhB8H,EAAgB9H,cACd4D,EAAeL,SACzBwE,EAAS,CAAEC,EAAG,UAAWC,EAAG,WAC5BC,EAAYxG,EAAS,GACrByG,EAAWzG,EAAS,GACpB0G,EAAW1G,EAAS,GACpB2G,EAAa3G,EAAS,GAExB4G,EAAwB,GACxBC,GAAY,IAAIC,MAAOC,UACvB1D,GAAU,WAELmB,EAAUjB,EAAUlE,GAC3BgE,GAAWE,EAAIyD,YACTC,EAAIZ,EAAOhH,GACXY,EAAQoD,EAAUE,EAAI0D,GAAK1D,EAAIyD,QAAQ,GAAGC,UACzCN,EAAWlH,IAAIQ,SAwCE,CACxBgE,qBAtCmBV,OACb2D,EAAQ1C,EAAUjB,EAAKrB,UAC7BsE,EAAU/G,IAAIyH,GACdR,EAASjH,IAAIyH,GACNd,EAAYtH,QAAQ0H,EAAUhH,QAmCrCuF,qBAhCmBxB,OACb2D,EAAQ1C,EAAUjB,EAAKrB,GACvBiF,GAAQ,IAAIL,MAAOC,iBAGrBI,EAFUN,GAtBM,KAyBlBD,EAAY1F,KAAKgG,EAAM1H,OACvBqH,EAAYM,GAGdV,EAAShH,IAAIyH,GAAO3G,SAASmG,GAC7BA,EAASjH,IAAIyH,GACNd,EAAYtH,QAAQ2H,EAASjH,QAqBpC4F,yBAjBMgC,EAAeV,EAASlH,MACxB6H,EAAchE,EAAU,EAAI,EAC5B6D,EAAQN,EACXU,OAAOD,GACPE,KAAI,SAAAC,UAAcJ,EAAeI,KACjCC,MAAK,SAACC,EAAIC,UACF9H,KAAKC,IAAI4H,GAAM7H,KAAKC,IAAI6H,GAAM,GAAK,KACzC,UAELjB,EAASjH,IAAIyH,GAAS,GACtBN,EAAc,GACPR,EAAYtH,QAAQ4H,EAASlH,QAOpCgF,sBC1DYoD,EAAMtJ,OACZa,EAAab,MAARc,EAAQd,MACfuJ,EAAa,CAAE1I,IAAKC,EAAKA,IAAKD,GAC9B2I,EAAkB,CAAE3I,MAAKC,OACzBmC,EAAS1B,KAAKC,IAAIX,EAAMC,YAErB2I,EAAWnJ,UACXA,EAAIO,WAGJ6I,EAAWpJ,UACXA,EAAIQ,WAOJ6I,EAAarJ,UAChBmJ,EAAWnJ,GAAW,MACtBoJ,EAAWpJ,GAAW,MACnB,SAoBW,CAClBsJ,mBANiBtJ,OACXuJ,EAAQF,EAAarJ,UACpBuJ,EAAQL,EAAgBK,GAASvJ,GAKxC2C,SACArC,cAbYN,OACNuJ,EAAQF,EAAarJ,UACpBuJ,EAAQN,EAAWM,GAASvJ,GAYnCQ,MACAD,MACA8F,oBAjCkBrG,UACXmJ,EAAWnJ,IAAMoJ,EAAWpJ,IAiCnCoJ,aACAD,aACAK,sBA1BoBxJ,MAChBO,IAAQC,EAAK,OAAOR,OACjBmJ,EAAWnJ,IAAIA,GAAK2C,OACpByG,EAAWpJ,IAAIA,GAAK2C,SACpB3C,aClBKyJ,EACdC,OAEMC,EAAM1I,KAAK0I,IAAI,GAAID,UAClB,SAAC1J,UAAciB,KAAK2I,MAAM5J,EAAI2J,GAAOA,YAc9BE,EAAuBC,UAC9BC,OAAOC,KAAKF,GAAOnB,IAAIxI,iBAGhB8J,EACd/H,EACAgI,OAEMC,EAAKjI,EAAKkI,UACZD,EAAGE,SAASH,IAAYC,EAAGzH,OAAOwH,YAGxBI,EAASpI,EAAmBgI,OACpCC,EAAKjI,EAAKkI,UACXD,EAAGE,SAASH,IAAYC,EAAGpJ,IAAImJ,YCvCtBK,EAAW7K,OACjB0D,EAA0B1D,WAAhB8K,EAAgB9K,QAAT+K,EAAS/K,OAC5BgL,EAAqBjB,EAAgB,GACrCkB,EAAWvJ,EAAS,GACpBwJ,EAAexJ,EAAS,GACxByJ,EAAazJ,EAAS,GACtBS,EAAYD,EAAU,GACtBkJ,EAAQ,CAAEN,QAAOC,iBAkCdlF,EAASvF,UAChB8K,EAAMN,MAAQxK,EACPc,WAQAiK,EAAQ/K,UACf8K,EAAML,KAAOzK,EACNc,MAQHA,EAAmB,CACvBe,YACAuB,WACA4H,cA5CYlJ,GACZ+I,EAAWhK,IAAIiB,GAAGH,SAASyB,OD1C7B/B,EACA4J,EACAC,EACAC,EACAC,ECuCQC,EAAYR,EAAWjK,MACvB0K,GD5CRjK,EC4CgBgK,ED3ChBJ,EC2C2B,ED1C3BC,EC0C8B,IDzC9BC,ECyCmC,EDxCnCC,ECwCsCN,EAAMN,MDrC1CW,GAA8B9J,EAAQ4J,IAAWC,EAAQD,IAA/CG,EAAQD,WCsClBtJ,EAAUhB,IAAIgK,GACdA,EACGnJ,YACAD,SAAS6J,GACT3J,SAASgJ,YAbM7I,GAClBA,EAAEP,OAAOuJ,EAAML,MACfG,EAAa7J,IAAIe,GAYjByJ,CAAWV,GACJ/J,GAmCP0K,gBAhCc1J,OACRoE,EAAOpE,EAAElB,MAAQwC,EAASxC,MAE1B6K,GADcf,EAAmBxE,UAEnCuF,GAAYrI,EAASvC,IAAIiB,GACtB2J,GA4BPC,kBAxDAf,EAAS5J,IAAI6J,GACbxH,EAASrC,IAAI4J,GACbC,EAAanJ,SAAS,IAuDtB6D,iCAVAyF,EAAQN,GACD3J,GAUP6K,kCArBApG,EAASiF,GACF1J,GAqBPiK,UACAxF,mBAEKzE,WC7EO8K,EAAalM,OACnBW,EAA2CX,QAApC0D,EAAoC1D,WAA1BoD,EAA0BpD,aAAdsD,EAActD,YAC3Ca,EAAqCF,MAAhCG,EAAgCH,MAA3B8I,EAA2B9I,aAAf+I,EAAe/I,aAEzCwL,GAAW,EACXC,EAAU,QAyBa,CACzBxC,mBAjBiBxH,aAPMA,UACnB+J,IAAYC,IACZ3C,EAAW/F,EAASxC,OAAekB,EAAElB,QAAUL,IAC/C6I,EAAWhG,EAASxC,QAAekB,EAAElB,QAAUJ,IAK9CuL,CAAgBjK,KAErBgK,EAAUE,OAAOC,YAAW,eACpBC,EAAa7L,EAAMiJ,UAAUxH,EAAElB,OACrCkB,EAAEjB,IAAIqL,GACNpJ,EAAWyC,SAAS,IAAIwF,QAAQ,GAChC/H,EAAUlD,QACVgM,EAAU,IAnBI,MA6BhBK,sBANoBC,GACpBP,GAAYO,aC7BAC,EAAc3M,OACpB4M,EAAqC5M,YAA1B6M,EAA0B7M,cAAbC,EAAaD,WACvC8M,EAAexD,EAAM,CAAEzI,KAAMgM,EAAc5M,EAAUa,IAAK,IAC1DiM,EAAoB,CAACH,EAAUpM,QAAQqM,IACvCG,EAAqBH,EAAc5M,QAmBb,CAC1BO,iBAVeyM,EAAuBC,OAChCC,EAAiBF,EAAYhE,IAAI6D,EAAalD,WAC9CwD,WAVgBH,OAChBI,EAAYJ,EAAY,GACxBK,EAAUL,EAAYA,EAAYhK,OAAS,UAG1CqG,EAAM,CAAEzI,IAFHoM,EAAYM,YAAYF,GAAa,EAE7BvM,IADRmM,EAAYxH,QAAQ6H,KAMXE,CAAeL,GAA5BtM,QAAKC,eAERkM,EACAE,EACEC,EAAenE,MAAMnI,EAAM,EAAGC,EAAM,GADzBqM,EADcJ,aClBpBU,EAAazN,OACnB6M,EAA8C7M,cAAjC0D,EAAiC1D,WAAvBW,EAAuBX,QAAhB8H,EAAgB9H,cAGhDoN,EAA6B9D,EAAM,CAAEzI,IAF/BF,EAAME,IAAMiH,EAAYtH,QAAQ,IAEIM,IADpCH,EAAMG,IAAMgH,EAAYtH,QAAQ,MACpCiJ,eAAYC,qBAeO,CACzB9I,cARY8M,EAAqBvL,eANfA,UACA,IAAdA,EAAwBuH,EAAWhG,EAASxC,QAC7B,IAAfiB,GAAyBsH,EAAW/F,EAASxC,OAK5CyM,CAAWxL,QAEVyL,EAAef,IAA4B,EAAb1K,GACpCuL,EAAQG,SAAQ,SAAAzL,UAAKA,EAAEf,IAAIuM,kBCPfE,EAAa9N,OACnBY,EAA0CZ,OAApCW,EAAoCX,QAA7BiN,EAA6BjN,cAAhB6M,EAAgB7M,cAC1C0J,EAAyC/I,aAA7BgG,EAA6BhG,aAAjBmJ,EAAiBnJ,wBAExCoN,EAAYC,EAAYC,UACxB1M,KAAKC,IAAIwM,GAAMzM,KAAKC,IAAIyM,GAAMD,EAAKC,WAenCC,EAAS/K,EAAgBhB,OAC1BgM,EAAKhL,EACLiL,EAAKjL,EAAS0J,EACdwB,EAAKlL,EAAS0J,MAEfjM,EAAM,OAAOuN,MACbhM,EAAW,OAAO4L,EAAYA,EAAYI,EAAIC,GAAKC,OAElDC,EAAWP,EAAYI,EAAkB,IAAdhM,EAAkBiM,EAAKC,UACjD9M,KAAKC,IAAI8M,GAAYnM,QA+BH,CACzBgF,oBAfkBC,EAAkBmH,OAC9BpL,EAASnD,EAAOmD,OAAOjC,MAAQkG,EAC/BoH,WAxCgBrL,OAChBiE,EAAW0C,EAAa3G,SAQvB,CAAE8D,MAPegG,EACrBhE,KAAI,SAAAwF,UAAcA,EAAarH,KAC/B6B,KAAI,SAAAyF,UAAcR,EAASQ,EAAY,MACvCzF,KAAI,SAACzC,EAAMmI,SAAO,CAAEnI,OAAMS,MAAO0H,MACjCxF,MAAK,SAAC6E,EAAIC,UAAO1M,KAAKC,IAAIwM,EAAGxH,MAAQjF,KAAKC,IAAIyM,EAAGzH,SAElB,SAClBY,YA+BGwH,CAAezL,GAC5B8D,WAjBiB9D,EAAgB8D,SACjBrG,GAAQ+F,EAAWxD,IACtB,OAAO8D,MAEpBmG,EAAepN,EAAOiH,MAApBpG,QAAKC,eACN4I,EAAWvG,GAAUtC,EAAMC,EAYpB+N,CAAgB1L,EAAQqL,EAAWvH,OAC3C6H,GAAgBlO,GAAQ+F,EAAWxD,UAEpCoL,GAAQO,EAAqB,CAAE7H,QAAOG,YAKpC,CAAEH,QAAOG,SAFKA,EAAW8G,EADbjB,EAAYhG,GAASuH,EAAWpH,SACE,KAOrD2H,iBAtBe9H,EAAe9E,SAGvB,CAAE8E,QAAOG,SADC8G,EADEjB,EAAYhG,GAASjH,EAAOmD,OAAOjC,MAChBiB,KAqBtC+L,qBC5DYc,EAAYhP,OAuElBiP,EACAC,EACA9O,EAxEAmD,EAAsCvD,OAAtBmP,EAAsBnP,WACtC6M,EAAmD7M,cAAtCC,EAAsCD,WAA5BoP,EAA4BpP,aAAhBiN,EAAgBjN,cACrDqP,EAAWlF,EAAUiF,GACrBE,EAAYnF,EAAUiF,GAAYG,UAClCC,GAkEEP,EAAMhC,EAAY,GAAK,EACvBiC,EAAUO,EAAYR,EAAKK,GAC3BlP,EAAQsP,EAAUT,EAAKC,EAAS,GAC/BS,EAAcT,EAAS9O,EAAO,IArENwP,sBA0EzBV,EAAUO,EADJxP,EAAWgN,EAAY,GAAK,EACPoC,GAC3BjP,EAAQsP,EAAU7C,EAAawC,GAAWpP,UACzC0P,EAAcT,GAAU9O,EAAO,GA5EAyP,IAClCC,EAA4B,MAAhBvM,EAAKwM,OAAiB,OAAS,eAExCC,EACPd,EACAe,UAEOf,EAAQgB,QAAO,SAACC,EAAWxB,UAEzBwB,EADMf,EAAWT,KAEvBsB,YAGIR,EACPW,EACAlB,UAEOA,EAAQgB,QAAO,SAACC,EAAaxB,UAClBqB,EAAkBG,EAAGC,GACpB,EAAID,EAAEP,OAAO,CAACjB,IAAMwB,IACpC,aAGIT,EACPU,EACAlB,EACAe,UAEOf,EAAQgB,QAAO,SAACC,EAAWxB,OAC1B0B,EAAYF,EAAIf,EAAWT,UAC1B0B,EAAYD,EAAYC,EAAYF,IAC1CF,YAeIN,EACPT,EACAe,EACA9N,OAEMmO,EAAapB,EAAQlG,QAAQG,MAAK,SAACgH,EAAGI,UAAMJ,EAAII,YAC/CD,EAAWrH,KAChB,SAAChC,EAAOuJ,OACAC,EAAU5D,GAAgB1K,GAAiB,EAAL,GACtCuO,EAAS7D,GAAgB1K,EAAgB,EAAJ,GAErCyG,WAtBVsG,EACAe,EACA9N,OAEMwO,EAAatB,EAASpM,OAAS,SAC9B+M,EACLd,EAAQjG,KAAI,SAAA0F,UAAMA,EAAIxM,GAAawO,KACnCV,GAegBW,CADON,EAAWtH,MAAM,EAAGwH,GACAP,EAAM9N,SAGxC,CAAEyG,QAAOiI,UAFE,SAACnN,UACjBA,EAAWkF,EAAQ6H,EAAUC,GACJzJ,QAAOvD,UAAW,YA2CzB,CACxBoN,0BAxBOtB,EAAWuB,OAAM,SAAC3D,OAAEnG,iBAElB+I,EADcX,EAAStM,QAAO,SAAA4L,UAAKA,IAAM1H,KACThH,IAAa,MAuBtD+Q,eARaC,GACbzB,EAAW3B,SAAQ,SAACT,OAAEnG,UACpBgK,EAAOhK,GAAOiK,MAAMpB,GAAa,OAOnClP,cApBYqQ,GACZzB,EAAW3B,SAAQ,SAAAsD,OACTN,EAA+BM,YAApBzN,EAAoByN,WAAVlK,EAAUkK,QACjChO,EAAS0N,EAAU1B,EAAkBjO,OACvCiC,IAAWO,IACbuN,EAAOhK,GAAOiK,MAAMpB,GAAgB3M,MACpCgO,EAAUzN,SAAWP,OAezBqM,uBCvHY4B,EAAapR,OACnB6M,EAAsC7M,cAAzBoP,EAAyBpP,aAAbC,EAAaD,WACtCqR,EAA0BrR,kBAATY,EAASZ,OAC5BsR,EAAalC,EAAWnG,KAAI,SAAAsI,UAAKA,EAAIF,KACrCpE,EAAc9C,EAAUiF,GAAYnG,cAGtBhC,UACLmI,EAAWpG,MAAM,EAAG/B,GACrBiJ,QAAO,SAACC,EAAGoB,UAAMpB,EAAIoB,IAAG,MAJhCC,GAQY5Q,EAAO,CAAC,EAAGiM,GAAcA,GAAe,CAAC,IAC1C5D,IAAIwI,GAAavB,QAAO,SAACC,EAAGI,UAAMJ,EAAEP,OAAOW,KAAI,aAGvDkB,EAAYf,UACZzD,EAAYhE,KAAI,SAACsF,EAAMtH,SAAW,CACvC7G,MAAOmO,EAAOa,EAAWnI,GAASqK,EAAWrK,GAASyJ,EACtDnQ,IAAKgO,EAAOtO,EAAWqR,EAAWrK,GAASyJ,EAC3CzJ,kBAauB,CACzByK,eAVahO,UACN8N,EAActB,QAAO,SAACyB,EAAgB/I,OACnC3B,EAAsB2B,QAAfxI,EAAewI,QAARrI,EAAQqI,eACU,IAAzB+I,EAAKlM,QAAQwB,MACb7G,EAAQsD,GAAYnD,EAAMmD,GACdiO,EAAK/B,OAAO,CAAC3I,IAAU0K,IACjD,eCpCSC,EAAU5R,OAChBuD,EAAoBvD,OAAd6R,EAAc7R,YAEtB8R,EADa,CAAE9J,WAOV1H,SACF,eAAeA,gBARA2H,WAWb3H,SACF,mBAAmBA,aAXKiD,EAAKwM,QAChC/E,EAAqBjB,EAAgB,GACrCgI,EAAiBF,EAAUX,MAC7B/E,GAAW,EACXzI,EAAW,QA8BS,CACtBsN,iBALAe,EAAeC,UAAY,GAC3BtO,EAAW,GAKXuO,YAtBU7P,OACN+J,OACEhJ,EAAS6H,EAAmB5I,EAAElB,OAEhCwC,IAAaP,IACf+O,iBAAiBL,GAAWG,UAC5BD,EAAeC,UAAYF,EAAc3O,GACzCO,EAAWP,KAgBbsJ,sBAZoBC,GACpBP,GAAYO,aCKAyF,EACdC,EACAP,EACAZ,EACAvO,EACAiB,OC5C6B3D,EACvBoN,EAAEtM,EAAauR,ED+CnBnS,EASEwC,QARIkB,EAQJlB,OAPF4P,EAOE5P,aANF2O,EAME3O,kBALF9B,EAKE8B,OAJFoI,EAIEpI,QAHFW,EAGEX,WAFF6P,EAEE7P,iBADF8P,EACE9P,gBAGEa,WE9DaA,OACbwM,EAAkB,MAATxM,EAAe,IAAM,UAQjB,CACjBkP,MARqB,MAATlP,EAAe,IAAM,IASjC/C,iBAPegC,OACT4K,EAAoB5K,EAAKkQ,wBAAvBC,UAAOC,iBACG,MAAX7C,EAAiB4C,EAAQC,GAMhC7C,UFkDW8C,CAAKjP,GACZkE,WGlEoBgL,OAOpB1R,EAAoB,CACxBZ,iBALeF,UACPA,EAAIwS,EAHO,KAQnBC,aARmB,YAUd1I,OAAO2I,OAAO5R,GHuDD6R,CAAY1P,EAAK/C,QAAQqR,IACvC5R,EAAW6H,EAAYiL,aACvB3D,EAAa6B,EAAOhI,IAAI1F,EAAK/C,SAASyI,IAAInB,EAAYtH,SAEtD0S,WTtCN9I,EACA+I,WAEMC,EAAS,GACNzE,EAAI,EAAGA,EAAIvE,EAAMnH,OAAQ0L,GAAKwE,EACrCC,EAAOxQ,KAAKwH,EAAMpB,MAAM2F,EAAGA,EAAIwE,WAE1BC,ES8BcC,CAAWjE,EAAYmD,GACbtJ,KAAI,SAAAqK,UAAKA,EAAEpD,QAAO,SAACC,EAAGoB,UAAMpB,EAAIoB,QACzDgC,EAAcpJ,EAAU+I,GACxBrG,EAAcuC,EAAWc,QAAO,SAACC,EAAGoB,UAAMpB,EAAIoB,IAAG,GACjD3E,EAAY7M,EAAU,CAAEG,QAAOD,aAC/BwO,WIjEmBzO,OAOjBgB,EANAkS,EAA+BlT,YAApB4M,EAAoB5M,YAATY,EAASZ,OACjCwT,EAAaN,EAAUjK,IAAI2D,EAAUpM,SACrCiT,GAIEzS,EAAUN,EAAQ,CAAEC,MADZ2I,EAAM,CAAEzI,IAAK,EAAGC,IAAKoS,EAAUjQ,OAAS,IACrB7C,MAAO,EAAGQ,SAEpCsS,EAAUjK,KAAI,SAACkK,EAAMlM,OACpBK,EAAOtG,EAAQG,IAAI8F,EAAQ,GAAG/F,aAC7BiS,EAAOK,EAAWvM,GAASuM,EAAWlM,aASxB,CACvB9G,iBANeyG,UACDwM,EAAiBzK,MAAM,EAAG/B,GAC3BiJ,QAAO,SAACC,EAAGoB,UAAMpB,EAAIoB,IAAGiC,EAAW,MJgD/BE,CAAW,CAAER,YAAWtG,YAAWhM,SAChD+S,EAAeJ,EAAYtK,IAAIwF,EAAWjO,SAC1CoT,EAAUjH,EAAc,CAAEC,YAAWC,cAAa5M,aAClD4T,GAAiBjT,GAA0B,KAAlB4R,EACzBsB,EAA8B,cAAlBtB,EACZrF,EAAiByG,EAAQpT,QAAQmT,EAAcG,GAC/C7G,EAAc4G,EAAgB1G,EAAiBwG,EAI/C1M,EAAQvG,EAAQ,CAAEC,MADN2I,EAAM,CAAEzI,IAAK,EAAGC,IAAKmM,EAAYhK,OAAS,IAClB7C,MAAOkS,EAAY1R,SACvDmT,EAAgB9M,EAAMxF,QAItBd,WKnFoBX,OAClB6M,EAAsB7M,cAATY,EAASZ,aAUJ,CACxBQ,iBATeyM,OACTI,EAAYJ,EAAY,GACxBK,EAAUL,EAAYA,EAAYhK,OAAS,UAG1CqG,EAAM,CAAEzI,IAFHD,EAAOyM,EAAYR,EAAcS,EAEzBxM,IADRuM,ML2EM2G,CAAY,CAAEpT,OAAMiM,gBACdrM,QAAQyM,GA0B5B3J,WMhHkB2Q,OAClBC,EAAMC,sBAAsBC,KAAK9H,QACjC/L,EAAM8T,qBAAqBD,KAAK9H,QAClCgI,EAAiB,WAEZC,EAAY7H,EAAiB8H,UAC7B,WACD9H,MAAa4H,GAAgBE,cAI5BpU,IACPkU,EAAiBJ,EAAID,SAQC,CACtBQ,QAASF,GAAY,EAAMnU,GAC3BA,MAAOmU,GAAY,EAAOnU,GAC1BsU,KAAMH,GAAY,cAPlBhU,EAAI+T,GACJA,EAAiB,MN+FDK,EAvBH,WACbC,GAAOxR,WAAWkI,KAAKnI,IAAQ6I,aACzB6I,EAAUD,GAAOxR,WAAW0I,OAAO3I,OAEpC2R,GAAYnP,gBACV/E,GAAMgU,GAAO9H,aAAalD,UAAUzG,IACrC0R,IACFD,GAAOtR,UAAUoR,OACjB/Q,EAAOwC,KAAK,YAGZvF,EAAM,KACFuB,EAAYyS,GAAOxR,WAAWjB,UAAUjB,MAC9C0T,GAAOG,aAAanU,KAAKoU,GAAa7S,GACtCyS,GAAOK,YAAYrU,KAAKqQ,GAGrB4D,GAASlR,EAAOwC,KAAK,UAC1ByO,GAAOM,UAAUjD,GAAG2C,GAAOxR,WAAWM,UACtCkR,GAAOtR,UAAUmR,aAKbU,EAAgBlI,EAAYhG,EAAM/F,OAClCwC,EAAWhC,EAASyT,GACpBhS,GAASzB,EAASyT,GAClBH,GAAc,CAACtR,EAAUP,IACzBC,GAAayH,EAAW,CAAEnH,WAAUoH,QAAOC,KAAM,IACjD/D,GAAe8G,EAAa,CAChCjB,cACA5F,QACAtG,QACAC,OACAqM,cACA9J,YAEI4D,YOlHiB/G,OACRoV,EAA0CpV,QAA5BgH,EAA4BhH,eAAdsD,EAActD,YACjD+T,EAAkD/T,gBAAnC2D,EAAmC3D,SAAnBqV,EAAmBrV,kBAEjD+G,EAAS5D,OACVmS,EAAenS,EAAOiE,SACtBC,EAAYlE,EAAO8D,QAAUmO,EAAalU,MAE5CoU,IACFhS,EAAUlD,QACViV,EAAehU,IAAIiU,IAEjBjO,IACF0M,EAAc5S,IAAIiU,EAAalU,OAC/BkU,EAAajU,IAAIgC,EAAO8D,OACxBtD,EAAOwC,KAAK,iBAeO,CACrBiB,kBAZgB9G,EAAWiO,GAE3BxH,EADeC,EAAaG,WAAW7G,EAAGiO,KAY1CtH,eARa3G,EAAW6B,OAClBoT,EAAcH,EAAa3T,QAAQN,IAAIb,GAE7CyG,EADeC,EAAa+H,QAAQwG,EAAYrU,MAAOiB,MPwFxCqT,CAAS,CACxBlS,YACAK,SACAsD,QACA8M,gBACA/M,gBACA7D,YAII2R,GAAc5R,EAAY,CAC9BI,YACAC,OACAF,WACAI,YAAaoE,EAAY,CACvBtE,OACAuE,gBAEFtE,QAAS4O,EACTzO,SACAsD,QACAtG,QACA+C,WACA9C,OACAwC,cACA2D,YACAC,gBACA7D,YAIIyR,GAAiB,CACrBtR,YACAC,OACAuR,eACAhN,cACAb,QACA8M,gBACApT,QACA+C,WACAhB,UACAU,cACA0J,aAAcZ,EAAa,CACzB5I,YACA3C,QACA+C,WACAN,gBAEF2R,aAActH,EAAa,CACzBZ,cACAlM,QACA+C,WACAoE,gBAEF2N,gBClL2BzV,EDkLI,CAC7BW,SClLEyM,EAAgCpN,EAAOW,MAArCG,QAAauR,WAOQ,CAC3BnR,aANWZ,UACaA,EAAIQ,IACFuR,KDgL1BpF,cACAjG,gBACAD,YACAkO,YAAajG,EAAY,CACvBzL,OACAsJ,cACAnJ,WACAuJ,cACAmC,aACAnP,aAEFyV,aAActE,EAAa,CACzBvE,cACAwE,kBACAzQ,OACAwO,aACAnP,aAEFsT,cACApQ,UACA+R,UAAWtD,EAAU,CACnBrO,OACAsO,sBAGG+C,GQnMF,IAAMe,EAA0B,CACrCzV,MAAO,SACPqD,KAAM,IACNiP,cAAe,GACfoD,kBAAmB,IACnBvS,UAAU,EACVwS,WAAW,EACXC,eAAgB,eAChBC,cAAe,cACf1E,gBAAiB,EACjBzQ,MAAM,EACNoV,cAAe,cACfzD,eAAgB,EAChBzH,MAAO,GACPwH,WAAY,UCFd,SACE2D,EACAC,gBAAAA,UlBhBAjC,EACAkC,EAEM/J,EkBqBFwI,EAIA/C,EACAZ,EAXEtN,iBChBApB,EAAuB,CAC3B6T,QAAS,GACTzQ,YAAa,GACbmB,UAAW,GACXuP,KAAM,GACNC,OAAQ,GACRC,OAAQ,GACRxG,OAAQ,GACRyG,OAAQ,GACR1K,OAAQ,IAkBJ1K,EAAqB,CACzB+E,cAhBYlB,UACZ1C,EAAU0C,GAAK4I,SAAQ,SAAA4I,UAAKA,EAAExR,MACvB7D,GAePsV,aAPWzR,EAAiBuP,UAC5BjS,EAAU0C,GAAO1C,EAAU0C,GAAKlC,QAAO,SAAA0T,UAAKA,IAAMjC,KAC3CpT,GAMPuV,YAbU1R,EAAiBuP,UAC3BjS,EAAU0C,GAAO1C,EAAU0C,GAAK2K,OAAO,CAAC4E,IACjCpT,WAaFA,EDhBQwV,GACTC,EAAavU,IACbwU,GlBpBN7C,iBkB0JQ8C,EAAmBnC,EAAOrR,KAAK/C,QAAQqR,GACzCmF,IAAkBD,GAAkBE,IACxCtT,EAAOwC,KAAK,WlB3JdgQ,EkBmByC,IlBjBnC/J,EAAU,CAAE8K,GAAI,GACf,WACL5K,OAAO6K,aAAa/K,EAAQ8K,IAC5B9K,EAAQ8K,GAAK5K,OAAOC,WAAW0H,EAAUkC,IAAS,IkBe9CG,EAASW,EACPN,EAAYhT,KAAR+S,EAAQ/S,MAGhByT,GAAY,EACZ1U,EAAU2U,EAAc,GAAI1B,GAC5BqB,EAAgB,WAMXM,QACFrB,EAAY,MAAM,IAAIsB,MAAM,4BlBxCnCC,EkB0CQC,EAAW/U,EAAQkT,kBACnB8B,EAAkBzB,EAAW0B,cAAcF,OAE5CC,EAAiB,MAAM,IAAIH,MAAM,6BlB7CxCC,GkB+CE3F,EAAY6F,GAC2BE,SAAvC3G,ElB9CK4G,MAAMC,UAAU9O,MAAM+O,KAAKP,YkBiDzBQ,EAASC,gBAAAA,MAChBX,IACA5U,EAAU2U,EAAc3U,EAASuV,OAI/B1U,GAHFqR,EAASzC,EAAO8D,EAAYpE,EAAWZ,EAAQvO,EAASiB,SAItDP,EAIEwR,aAHFM,EAGEN,YAFFE,EAEEF,cADFK,EACEL,cAEFhU,EAKE8B,OAJFmT,EAIEnT,YAHFoT,EAGEpT,iBAFFsT,EAEEtT,gBADFqT,EACErT,mBAEJsU,EAAgBzT,EAAK/C,QAAQqR,GAC7BgF,EAAWxV,IAAIiL,OAAQ,SAAUwK,GACjC5B,EAAUjD,GAAG7O,EAAWM,UACxBuN,EAAOpD,QAAQqK,GACfpD,EAAYnN,sBAER/G,EAAM,KACHqU,EAAYnE,UAAW,OAAOmG,EAAW,CAAErW,MAAM,IACtDqU,EAAYrU,KAAKqQ,GAEf4E,GACEC,GACFlL,EAASqL,EAAYH,GAEnBC,IACFpS,EAAOgT,GAAG,cAAewB,GACzBxU,EAAOgT,GAAG,YAAawB,KAGzBxU,EAAOgT,GAAG,cAAe7B,EAAYzQ,yBAEnC2R,IACFoC,IACAzU,EAAOgT,GAAG,SAAUyB,GACpBzU,EAAOgT,GAAG,YAAayB,IAEpBhB,IACH7K,YAAW,kBAAM5I,EAAOwC,KAAK,UAAS,GACtCiR,GAAY,YAIPe,EAAoBlT,OACnB8Q,EAAkBrT,gBACd,gBAARuC,EAAuB2F,EAASqL,EAAYF,GAC3CxL,EAAY0L,EAAYF,YAGtBqC,QACCpC,EAAkBtT,gBACpB2V,EAAS3C,GAAa,GACV4C,GAAgB,GACxBzK,SAAQ,SAAAc,UAAKpE,EAAY0G,EAAOtC,GAAIqH,MAC9CqC,EAAOxK,SAAQ,SAAAc,UAAK/D,EAASqG,EAAOtC,GAAIqH,eAGjCkC,EAAgBK,EAAoBtR,GAO3C4P,EAAWxV,IAAIkX,EAAO,SANR,eACNC,EAAajX,KAAKkX,MAAMxR,EAAQvE,EAAQ6P,gBACxCmG,EAAgBzR,EAAQuR,EAAavR,EAC3CgP,EAAW0C,WAAa,EACxB5R,EAAS2R,MAE2B,YAG/BzB,EAAWgB,gBAAAA,UAEZW,EAAavB,EAAc,CAAE/E,WADhBsC,EAAO3N,MAAM/F,OACiB+W,GACjDY,IACAb,EAASY,GACTjV,EAAOwC,KAAK,mBAGL0S,QACC7C,EAAkCtT,gBAAnBoT,EAAmBpT,iBAC1CkS,EAAOE,YAAY1Q,yBACnBwQ,EAAOE,YAAYzQ,0BACnBuQ,EAAOtR,UAAUoR,OACjBmC,EAAW/T,YACX8R,EAAOM,UAAUlE,QACjB4D,EAAOK,YAAYjE,MAAMC,GACzB1G,EAAY0L,EAAYH,GACxB7E,EAAOpD,SAAQ,SAAA0D,UAAKhH,EAAYgH,EAAGyE,MACnCrS,EAAO+S,IAAI,SAAU0B,GACrBzU,EAAO+S,IAAI,YAAa0B,GACxBzU,EAAO+S,IAAI,cAAeyB,GAC1BxU,EAAO+S,IAAI,YAAayB,YAiBjBzC,EAAavS,gBAAAA,UACdO,EAAWkR,EAAOzR,EAAS,SAAW,YAAYjC,MAClDH,EAAO2B,EAAQ9B,KAAO,eAAiB,mBACtCgU,EAAOc,aAAahE,MAAMkD,EAAOjU,MAAMI,GAAM2C,aAG7C4U,EAAgBnV,gBAAAA,UACjBkV,EAAS3C,EAAavS,UACrByR,EAAOrB,YAAYxQ,QAAO,SAAA4L,UAA4B,IAAvB0J,EAAO5S,QAAQkJ,eAQ9C5H,EAASE,GAChB2N,EAAOxR,WAAWwC,iBAAiBqG,kBACnC2I,EAAO7N,SAASE,MAAMA,EAAO,UAlJ/B+Q,EAAS9B,GAwMmB,CAC1B4C,6BAlCQ7R,EAAU2N,eACXlS,EAAQ9B,MAAQqG,EAAM/F,QAAU+F,EAAMnG,KAkC7CiY,6BAxCQ9R,EAAU2N,eACXlS,EAAQ9B,MAAQqG,EAAM/F,QAAU+F,EAAMpG,KAwC7C+G,+BAlBOgN,EAAOE,YAAYlN,gBAmB1BoR,gCAXOnH,GAYPoH,uCAhBOrE,GAiBPwB,mBA3FKgB,IACLyB,IACAzB,GAAY,EACZxC,EAAS,GACTjR,EAAOwC,KAAK,aAwFZuQ,MACAC,KACAuC,qCA5BOtE,EAAOb,cAAc7S,OA6B5BoV,SACA6C,0BA7DM7R,EAAOsN,EAAO3N,MAAMxF,QAAQJ,IAAI,GACtCuT,EAAOxR,WAAWwC,iBAAiBqG,kBACnC2I,EAAO7N,SAASE,MAAMK,EAAKpG,OAAQ,IA4DnCkY,0BAxDMC,EAAOzE,EAAO3N,MAAMxF,QAAQJ,KAAK,GACvCuT,EAAOxR,WAAWwC,iBAAiBqG,kBACnC2I,EAAO7N,SAASE,MAAMoS,EAAKnY,MAAO,IAuDlCuU,8BAzCM/R,EAAWkR,EAAOlR,SAASxC,aAC1B0T,EAAOa,eAAevU,IAAIwC,IAyCjC4V,8BA1EMC,EAAoB3E,EAAOa,eAAevU,WACzC0T,EAAO3H,YAAYhE,IAAIsQ,IA0E9BxS,WACAyS,qCAvCO5E,EAAO3N,MAAM/F,OAwCpBuY,6BApBOxI,GAqBPyE,eACA4C"}